PHASE 1: BASICS OF PROGRAMMING (if you're a complete beginner)
âœ… If you already know how to code (loops, functions, etc.), skip to Phase 2.

Variables and Data Types

Operators (Arithmetic, Logical, Bitwise)

Input/Output

Conditional Statements (if-else, switch)

Loops (for, while, do-while)

Functions (Recursion Basics here)

Arrays (1D and 2D)

String Basics

ğŸš€ PHASE 2: TIME & SPACE COMPLEXITY
What is Time Complexity?

What is Space Complexity?

Big O, Big Î©, Big Î˜

Best, Worst, Average Cases

How to Calculate Time Complexity

Common Time Complexities (O(1), O(n), O(log n), etc.)

ğŸ§  PHASE 3: BASIC DATA STRUCTURES
ğŸ”¹ Arrays
Traversal, Insertion, Deletion

Searching (Linear, Binary Search)

Sorting Algorithms (Bubble, Selection, Insertion, Merge, Quick)

Two Pointers Technique

Prefix Sum Technique

Sliding Window Technique

ğŸ”¹ Strings
String Manipulation

Palindromes, Anagrams

Pattern Matching (Naive, KMP, Rabin-Karp)

String Builder / Mutable Strings

Substrings and Subsequence

ğŸ”¹ Linked List
Singly Linked List (Insert, Delete, Reverse)

Doubly Linked List

Circular Linked List

Floydâ€™s Cycle Detection

Merge Two Sorted Lists

Intersection Point of Two Lists

Detect and Remove Loop

ğŸ§© PHASE 4: MATHS FOR DSA
Prime Numbers (Sieve of Eratosthenes)

GCD, LCM (Euclidean Algorithm)

Modular Arithmetic

Bit Manipulation (AND, OR, XOR, Left/Right Shift)

Counting Set Bits

Power of Two, Power Calculation (Fast Exponentiation)

ğŸ“š PHASE 5: STACKS & QUEUES
ğŸ”¹ Stack
Implementation (Array/Linked List)

Infix, Prefix, Postfix

Balanced Parentheses

Next Greater Element

Stock Span Problem

Min Stack

ğŸ”¹ Queue
Implementation (Array/Linked List)

Circular Queue

Deque (Double-Ended Queue)

Sliding Window Maximum

LRU Cache (Using Deque + HashMap)

ğŸŒ³ PHASE 6: TREES
Binary Trees (Traversals: Inorder, Preorder, Postorder)

Binary Search Trees (BST)

Height, Diameter

Lowest Common Ancestor (LCA)

Balanced Tree (AVL Concept)

Tree to DLL

Serialize & Deserialize Binary Tree

Trie (Prefix Tree)

Segment Tree (Lazy Propagation)

ğŸ§­ PHASE 7: HEAP / PRIORITY QUEUE
Binary Heap (Min & Max Heap)

Heapify and Heap Sort

Priority Queue in STL / Java / Python

K Largest / K Smallest Elements

Median of a Stream

Merge K Sorted Arrays / Lists

ğŸ”— PHASE 8: HASHING / HASHMAP
HashTable, HashSet

Frequency Count

Subarray with 0 Sum

Count Distinct Elements

Longest Consecutive Subsequence

Group Anagrams

LRU Cache using HashMap

ğŸ”„ PHASE 9: RECURSION & BACKTRACKING
Basics of Recursion

Factorial, Fibonacci, Sum of Digits

Permutations and Combinations

N-Queens Problem

Sudoku Solver

Subset / Subsequence

Rat in a Maze

Word Search

ğŸ•¸ï¸ PHASE 10: GRAPHS
Graph Representation (Adjacency List & Matrix)

BFS and DFS

Detect Cycle in Graph (Undirected & Directed)

Topological Sorting

Dijkstraâ€™s Algorithm

Bellman-Ford

Floyd-Warshall

Minimum Spanning Tree (Primâ€™s and Kruskalâ€™s)

Disjoint Set Union (DSU)

Bridges and Articulation Points

Kosarajuâ€™s Algorithm (Strongly Connected Components)

ğŸ’¡ PHASE 11: DYNAMIC PROGRAMMING (DP)
Recursion to Memoization

Tabulation

1D DP:

Fibonacci

Climbing Stairs

Minimum Cost Climbing

2D DP:

0/1 Knapsack

Subset Sum

Equal Partition

Longest Common Subsequence

Longest Palindromic Substring

Edit Distance

DP on Trees

DP on Graphs

Bitmask DP

ğŸ§ª PHASE 12: PRACTICE & APPLICATIONS
Leetcode Patterns (Blind 75, Neetcode 150)

InterviewBit Topics

Codeforces / CodeChef Practice

Mock Contests

Build Projects that use DSA (like autocomplete, pathfinding visualizer)